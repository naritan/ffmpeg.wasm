{"version":3,"file":"814.ffmpeg.js","mappings":"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","sources":["webpack://FFmpegWASM/webpack/universalModuleDefinition","webpack://FFmpegWASM/./dist/esm/ lazy namespace object","webpack://FFmpegWASM/webpack/bootstrap","webpack://FFmpegWASM/webpack/runtime/hasOwnProperty shorthand","webpack://FFmpegWASM/./dist/esm/const.js","webpack://FFmpegWASM/./dist/esm/errors.js","webpack://FFmpegWASM/./dist/esm/worker.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FFmpegWASM\"] = factory();\n\telse\n\t\troot[\"FFmpegWASM\"] = factory();\n})(self, () => {\nreturn ","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 454;\nmodule.exports = webpackEmptyAsyncContext;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export const MIME_TYPE_JAVASCRIPT = \"text/javascript\";\nexport const MIME_TYPE_WASM = \"application/wasm\";\nexport const CORE_VERSION = \"0.12.10\";\nexport const CORE_URL = `https://unpkg.com/@ffmpeg/core@${CORE_VERSION}/dist/umd/ffmpeg-core.js`;\nexport var FFMessageType;\n(function (FFMessageType) {\n    FFMessageType[\"LOAD\"] = \"LOAD\";\n    FFMessageType[\"EXEC\"] = \"EXEC\";\n    FFMessageType[\"FFPROBE\"] = \"FFPROBE\";\n    FFMessageType[\"WRITE_FILE\"] = \"WRITE_FILE\";\n    FFMessageType[\"READ_FILE\"] = \"READ_FILE\";\n    FFMessageType[\"DELETE_FILE\"] = \"DELETE_FILE\";\n    FFMessageType[\"RENAME\"] = \"RENAME\";\n    FFMessageType[\"CREATE_DIR\"] = \"CREATE_DIR\";\n    FFMessageType[\"LIST_DIR\"] = \"LIST_DIR\";\n    FFMessageType[\"DELETE_DIR\"] = \"DELETE_DIR\";\n    FFMessageType[\"ERROR\"] = \"ERROR\";\n    FFMessageType[\"DOWNLOAD\"] = \"DOWNLOAD\";\n    FFMessageType[\"PROGRESS\"] = \"PROGRESS\";\n    FFMessageType[\"LOG\"] = \"LOG\";\n    FFMessageType[\"MOUNT\"] = \"MOUNT\";\n    FFMessageType[\"UNMOUNT\"] = \"UNMOUNT\";\n    // WebCodecs integration\n    FFMessageType[\"WRITE_FRAME\"] = \"WRITE_FRAME\";\n    FFMessageType[\"READ_FRAME\"] = \"READ_FRAME\";\n    FFMessageType[\"INIT_FILTER\"] = \"INIT_FILTER\";\n    FFMessageType[\"PROCESS_FRAME\"] = \"PROCESS_FRAME\";\n    FFMessageType[\"CLOSE_FILTER\"] = \"CLOSE_FILTER\";\n})(FFMessageType || (FFMessageType = {}));\n","export const ERROR_UNKNOWN_MESSAGE_TYPE = new Error(\"unknown message type\");\nexport const ERROR_NOT_LOADED = new Error(\"ffmpeg is not loaded, call `await ffmpeg.load()` first\");\nexport const ERROR_TERMINATED = new Error(\"called FFmpeg.terminate()\");\nexport const ERROR_IMPORT_FAILURE = new Error(\"failed to import ffmpeg-core.js\");\n","/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\nimport { CORE_URL, FFMessageType } from \"./const.js\";\nimport { ERROR_UNKNOWN_MESSAGE_TYPE, ERROR_NOT_LOADED, ERROR_IMPORT_FAILURE, } from \"./errors.js\";\nlet ffmpeg;\nconst load = async ({ coreURL: _coreURL, wasmURL: _wasmURL, workerURL: _workerURL, }) => {\n    const first = !ffmpeg;\n    try {\n        if (!_coreURL)\n            _coreURL = CORE_URL;\n        // when web worker type is `classic`.\n        importScripts(_coreURL);\n    }\n    catch {\n        if (!_coreURL || _coreURL === CORE_URL)\n            _coreURL = CORE_URL.replace('/umd/', '/esm/');\n        // when web worker type is `module`.\n        self.createFFmpegCore = (await import(\n        /* @vite-ignore */ _coreURL)).default;\n        if (!self.createFFmpegCore) {\n            throw ERROR_IMPORT_FAILURE;\n        }\n    }\n    const coreURL = _coreURL;\n    const wasmURL = _wasmURL ? _wasmURL : _coreURL.replace(/.js$/g, \".wasm\");\n    const workerURL = _workerURL\n        ? _workerURL\n        : _coreURL.replace(/.js$/g, \".worker.js\");\n    ffmpeg = await self.createFFmpegCore({\n        // Fix `Overload resolution failed.` when using multi-threaded ffmpeg-core.\n        // Encoded wasmURL and workerURL in the URL as a hack to fix locateFile issue.\n        mainScriptUrlOrBlob: `${coreURL}#${btoa(JSON.stringify({ wasmURL, workerURL }))}`,\n    });\n    ffmpeg.setLogger((data) => self.postMessage({ type: FFMessageType.LOG, data }));\n    ffmpeg.setProgress((data) => self.postMessage({\n        type: FFMessageType.PROGRESS,\n        data,\n    }));\n    return first;\n};\nconst exec = ({ args, timeout = -1 }) => {\n    ffmpeg.setTimeout(timeout);\n    ffmpeg.exec(...args);\n    const ret = ffmpeg.ret;\n    ffmpeg.reset();\n    return ret;\n};\nconst ffprobe = ({ args, timeout = -1 }) => {\n    ffmpeg.setTimeout(timeout);\n    ffmpeg.ffprobe(...args);\n    const ret = ffmpeg.ret;\n    ffmpeg.reset();\n    return ret;\n};\nconst writeFile = ({ path, data }) => {\n    ffmpeg.FS.writeFile(path, data);\n    return true;\n};\nconst readFile = ({ path, encoding }) => ffmpeg.FS.readFile(path, { encoding });\n// TODO: check if deletion works.\nconst deleteFile = ({ path }) => {\n    ffmpeg.FS.unlink(path);\n    return true;\n};\nconst rename = ({ oldPath, newPath }) => {\n    ffmpeg.FS.rename(oldPath, newPath);\n    return true;\n};\n// TODO: check if creation works.\nconst createDir = ({ path }) => {\n    ffmpeg.FS.mkdir(path);\n    return true;\n};\nconst listDir = ({ path }) => {\n    const names = ffmpeg.FS.readdir(path);\n    const nodes = [];\n    for (const name of names) {\n        const stat = ffmpeg.FS.stat(`${path}/${name}`);\n        const isDir = ffmpeg.FS.isDir(stat.mode);\n        nodes.push({ name, isDir });\n    }\n    return nodes;\n};\n// TODO: check if deletion works.\nconst deleteDir = ({ path }) => {\n    ffmpeg.FS.rmdir(path);\n    return true;\n};\nconst mount = ({ fsType, options, mountPoint }) => {\n    const str = fsType;\n    const fs = ffmpeg.FS.filesystems[str];\n    if (!fs)\n        return false;\n    ffmpeg.FS.mount(fs, options, mountPoint);\n    return true;\n};\nconst unmount = ({ mountPoint }) => {\n    ffmpeg.FS.unmount(mountPoint);\n    return true;\n};\n// WebCodecs integration functions\nlet frameBuffer = [];\nlet filterContext = null;\nconst writeFrame = ({ frameData, timestamp }) => {\n    if (!ffmpeg)\n        return false;\n    // Allocate memory for frame data\n    const dataPtr = ffmpeg._malloc(frameData.length);\n    ffmpeg.HEAPU8.set(frameData, dataPtr);\n    // Call C function\n    const result = ffmpeg._write_frame(dataPtr, frameData.length, timestamp);\n    // Free memory\n    ffmpeg._free(dataPtr);\n    return result === 0;\n};\nconst readFrame = ({ width = 1920, height = 1080 } = {}) => {\n    if (!ffmpeg)\n        return null;\n    // Allocate buffer for reading frame\n    const bufferSize = width * height * 3 / 2; // Buffer size for YUV420\n    const bufferPtr = ffmpeg._malloc(bufferSize);\n    const timestampPtr = ffmpeg._malloc(8); // int64_t\n    // Call C function\n    const size = ffmpeg._read_frame(bufferPtr, bufferSize, timestampPtr);\n    if (size <= 0) {\n        ffmpeg._free(bufferPtr);\n        ffmpeg._free(timestampPtr);\n        return null;\n    }\n    // Read data\n    const frameData = new Uint8Array(ffmpeg.HEAPU8.buffer, bufferPtr, size);\n    const timestamp = ffmpeg.getValue(timestampPtr, 'i64');\n    // Copy data before freeing\n    const result = {\n        frameData: new Uint8Array(frameData),\n        timestamp: timestamp\n    };\n    // Free memory\n    ffmpeg._free(bufferPtr);\n    ffmpeg._free(timestampPtr);\n    return result;\n};\nconst initFilter = ({ filterGraph, inputWidth, inputHeight, outputWidth, outputHeight }) => {\n    if (!ffmpeg)\n        return false;\n    // Convert string to C string\n    const filterPtr = ffmpeg._malloc(filterGraph.length + 1);\n    ffmpeg.stringToUTF8(filterGraph, filterPtr, filterGraph.length + 1);\n    // Call C function\n    const result = ffmpeg._init_filter(filterPtr, inputWidth, inputHeight, outputWidth, outputHeight);\n    // Free memory\n    ffmpeg._free(filterPtr);\n    return result === 0;\n};\nconst processFrame = ({ frameData, timestamp, outputWidth = 1920, outputHeight = 1080 }) => {\n    if (!ffmpeg)\n        throw new Error(\"FFmpeg not loaded\");\n    // Allocate memory for input and output\n    const inputPtr = ffmpeg._malloc(frameData.length);\n    const outputSize = outputWidth * outputHeight * 3 / 2; // Buffer size for output YUV420\n    const outputPtr = ffmpeg._malloc(outputSize);\n    // Copy input data\n    ffmpeg.HEAPU8.set(frameData, inputPtr);\n    // Call C function\n    const resultSize = ffmpeg._process_frame(inputPtr, frameData.length, timestamp, outputPtr, outputSize);\n    if (resultSize <= 0) {\n        ffmpeg._free(inputPtr);\n        ffmpeg._free(outputPtr);\n        throw new Error(\"Frame processing failed\");\n    }\n    // Read output data\n    const outputData = new Uint8Array(ffmpeg.HEAPU8.buffer, outputPtr, resultSize);\n    const result = {\n        frameData: new Uint8Array(outputData),\n        timestamp: timestamp\n    };\n    // Free memory\n    ffmpeg._free(inputPtr);\n    ffmpeg._free(outputPtr);\n    return result;\n};\nconst closeFilter = () => {\n    if (!ffmpeg)\n        return false;\n    // Call C function\n    ffmpeg._close_filter();\n    filterContext = null;\n    frameBuffer = [];\n    return true;\n};\nself.onmessage = async ({ data: { id, type, data: _data }, }) => {\n    const trans = [];\n    let data;\n    try {\n        if (type !== FFMessageType.LOAD && !ffmpeg)\n            throw ERROR_NOT_LOADED; // eslint-disable-line\n        switch (type) {\n            case FFMessageType.LOAD:\n                data = await load(_data);\n                break;\n            case FFMessageType.EXEC:\n                data = exec(_data);\n                break;\n            case FFMessageType.FFPROBE:\n                data = ffprobe(_data);\n                break;\n            case FFMessageType.WRITE_FILE:\n                data = writeFile(_data);\n                break;\n            case FFMessageType.READ_FILE:\n                data = readFile(_data);\n                break;\n            case FFMessageType.DELETE_FILE:\n                data = deleteFile(_data);\n                break;\n            case FFMessageType.RENAME:\n                data = rename(_data);\n                break;\n            case FFMessageType.CREATE_DIR:\n                data = createDir(_data);\n                break;\n            case FFMessageType.LIST_DIR:\n                data = listDir(_data);\n                break;\n            case FFMessageType.DELETE_DIR:\n                data = deleteDir(_data);\n                break;\n            case FFMessageType.MOUNT:\n                data = mount(_data);\n                break;\n            case FFMessageType.UNMOUNT:\n                data = unmount(_data);\n                break;\n            case FFMessageType.WRITE_FRAME:\n                data = writeFrame(_data);\n                break;\n            case FFMessageType.READ_FRAME:\n                data = readFrame(_data);\n                break;\n            case FFMessageType.INIT_FILTER:\n                data = initFilter(_data);\n                break;\n            case FFMessageType.PROCESS_FRAME:\n                data = processFrame(_data);\n                break;\n            case FFMessageType.CLOSE_FILTER:\n                data = closeFilter();\n                break;\n            default:\n                throw ERROR_UNKNOWN_MESSAGE_TYPE;\n        }\n    }\n    catch (e) {\n        self.postMessage({\n            id,\n            type: FFMessageType.ERROR,\n            data: e.toString(),\n        });\n        return;\n    }\n    if (data instanceof Uint8Array) {\n        trans.push(data.buffer);\n    }\n    self.postMessage({ id, type, data }, trans);\n};\n"],"names":["root","factory","exports","module","define","amd","self","webpackEmptyAsyncContext","req","Promise","resolve","then","e","Error","code","keys","id","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","o","obj","prop","Object","prototype","hasOwnProperty","call","CORE_URL","FFMessageType","ERROR_UNKNOWN_MESSAGE_TYPE","ERROR_NOT_LOADED","ERROR_IMPORT_FAILURE","ffmpeg","frameBuffer","filterContext","onmessage","async","data","type","_data","trans","LOAD","coreURL","_coreURL","wasmURL","_wasmURL","workerURL","_workerURL","first","importScripts","replace","createFFmpegCore","default","mainScriptUrlOrBlob","btoa","JSON","stringify","setLogger","postMessage","LOG","setProgress","PROGRESS","load","EXEC","args","timeout","setTimeout","exec","ret","reset","FFPROBE","ffprobe","WRITE_FILE","path","FS","writeFile","READ_FILE","encoding","readFile","DELETE_FILE","unlink","deleteFile","RENAME","oldPath","newPath","rename","CREATE_DIR","mkdir","createDir","LIST_DIR","names","readdir","nodes","name","stat","isDir","mode","push","listDir","DELETE_DIR","rmdir","deleteDir","MOUNT","fsType","options","mountPoint","str","fs","filesystems","mount","UNMOUNT","unmount","WRITE_FRAME","frameData","timestamp","dataPtr","_malloc","length","HEAPU8","set","result","_write_frame","_free","writeFrame","READ_FRAME","width","height","bufferSize","bufferPtr","timestampPtr","size","_read_frame","Uint8Array","buffer","getValue","readFrame","INIT_FILTER","filterGraph","inputWidth","inputHeight","outputWidth","outputHeight","filterPtr","stringToUTF8","_init_filter","initFilter","PROCESS_FRAME","inputPtr","outputSize","outputPtr","resultSize","_process_frame","outputData","processFrame","CLOSE_FILTER","_close_filter","ERROR","toString"],"sourceRoot":""}